<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Message — Fixed Messaging</title>
  <style>
    :root{
      --bg:#ffffff; --panel:#f7f7fb; --primary:#0a84ff; --muted:#8e8e93; --text:#111; --glass:rgba(0,0,0,0.04);
      --bubble-me:var(--primary); --bubble-other:#e5e6ea;
    }
    [data-theme="dark"]{ --bg:#0b1020; --panel:#0f1726; --primary:#4aa3ff; --muted:#9aa4b2; --text:#e8eef8; --bubble-me:#2b6cff; --bubble-other:#172033; --glass:rgba(255,255,255,0.03); }
    html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;background:var(--bg);color:var(--text);}
    .app{display:flex;flex-direction:column;height:100vh;max-width:980px;margin:0 auto;border-left:1px solid var(--glass);border-right:1px solid var(--glass);}
    header{display:flex;align-items:center;gap:12px;padding:10px 14px}
    .main{display:flex;flex:1;overflow:hidden}
    .col{flex-basis:320px;flex-shrink:0;border-right:1px solid var(--glass);background:var(--panel);overflow:auto}
    .col.full{flex:1;border-right:none;background:transparent}
    .list{padding:12px;display:flex;flex-direction:column;gap:10px}
    .user-row{display:flex;align-items:center;gap:12px;padding:8px;border-radius:10px;cursor:pointer}
    .avatar{width:44px;height:44px;border-radius:50%;background:#bbb;color:#fff;display:flex;align-items:center;justify-content:center;font-weight:700}
    .chat-wrap{display:flex;flex-direction:column;height:100%}
    .messages{flex:1;padding:20px 14px 120px;display:flex;flex-direction:column;gap:10px;overflow:auto}
    .msg{max-width:74%;padding:10px 12px;border-radius:16px;word-wrap:break-word}
    .msg.me{margin-left:auto;background:linear-gradient(180deg,var(--bubble-me),#0077e6);color:white}
    .msg.other{margin-right:auto;background:var(--bubble-other);color:var(--text)}
    .meta{font-size:11px;color:rgba(0,0,0,0.45);margin-top:6px}
    .composer{position:fixed;left:0;right:0;bottom:0;padding:12px;background:transparent;display:flex;justify-content:center}
    .composer-inner{width:100%;max-width:980px;padding:10px 14px;background:var(--panel);display:flex;gap:8px;border-top:1px solid var(--glass)}
    .text{flex:1;padding:10px 12px;border-radius:999px;border:1px solid var(--glass);background:transparent;color:var(--text);outline:none}
    .send{background:var(--primary);color:white;padding:10px 14px;border-radius:999px;border:none;font-weight:700;cursor:pointer}
    .small{font-size:13px;color:var(--muted)}
    .hidden{display:none}
  </style>
</head>
<body>
  <div class="app" id="app" data-theme="light">
    <header>
      <div style="display:flex;gap:10px;align-items:center">
        <div style="width:36px;height:36px;border-radius:8px;background:linear-gradient(180deg,var(--primary),#006fe6)"></div>
        <div style="font-weight:700">Mini Message (Fixed)</div>
      </div>
      <div style="flex:1"></div>
      <div id="auth-area"></div>
    </header>

    <div class="main">
      <div class="col" id="left-col">
        <div style="padding:12px;display:flex;align-items:center;gap:8px">
          <div class="small">Chats</div>
        </div>
        <div id="chats-list" class="list"></div>
      </div>

      <div class="col full" id="chat-col">
        <div id="chat-empty" style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--muted)">
          <div style="text-align:center;max-width:360px">
            <h3 style="margin:0 0 8px 0">No conversation selected</h3>
            <div class="small">Select someone to start messaging</div>
          </div>
        </div>

        <div class="chat-wrap hidden" id="chat-wrap" aria-live="polite">
          <div style="padding:12px;border-bottom:1px solid var(--glass);display:flex;align-items:center;gap:12px">
            <div id="chat-avatar" class="avatar">U</div>
            <div>
              <div id="chat-name" style="font-weight:700">User</div>
              <div id="chat-bio" class="small"></div>
            </div>
            <div style="flex:1"></div>
          </div>

          <div id="messages" class="messages" tabindex="0"></div>
        </div>
      </div>
    </div>

    <div class="composer" aria-hidden="false">
      <div class="composer-inner">
        <input id="text-input" class="text" placeholder="Message" />
        <button id="send-btn" class="send">Send</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously, signInWithPopup, GoogleAuthProvider, signOut } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, addDoc, collection, query, where, orderBy, limit, onSnapshot, serverTimestamp, enableIndexedDbPersistence, updateDoc } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCvaWRvpDY-BOOg_oitS4oVGDoQkiWMR6A",
      authDomain: "windowsassistant-36760.firebaseapp.com",
      projectId: "windowsassistant-36760",
      storageBucket: "windowsassistant-36760.firebasestorage.app",
      messagingSenderId: "125638102938",
      appId: "1:125638102938:web:42e36690e0b74096003423"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    try { await enableIndexedDbPersistence(db); } catch(e){ /* ignore multi-tab errors */ }

    const $ = sel => document.querySelector(sel);
    const create = (t,cls)=>{const e=document.createElement(t); if(cls) e.className=cls; return e;};
    const nowTs = ()=>serverTimestamp();

    let me = null;
    let activePeer = null;
    let messagesUnsub = null;
    let usersCache = {};
    let followsCache = new Set();

    const authArea = $('#auth-area');
    const chatsList = $('#chats-list');
    const chatWrap = $('#chat-wrap'), chatEmpty = $('#chat-empty');
    const messagesEl = $('#messages'), chatName = $('#chat-name'), chatBio = $('#chat-bio'), chatAvatar = $('#chat-avatar');
    const sendBtn = $('#send-btn'), textInput = $('#text-input');

    async function ensureProfile(user){
      const uRef = doc(db,'users',user.uid);
      const snap = await getDoc(uRef);
      if(!snap.exists()){
        const basic = { uid:user.uid, displayName:user.displayName || `User${user.uid.slice(0,6)}`, bio:'', createdAt: serverTimestamp(), theme:'light' };
        await setDoc(uRef,basic);
        usersCache[user.uid]=basic;
        return basic;
      } else {
        const data = snap.data(); usersCache[user.uid]=data; return data;
      }
    }

    onAuthStateChanged(auth, async user=>{
      if(!user){ try{ await signInAnonymously(auth); }catch(e){ console.error(e);} return; }
      const profile = await ensureProfile(user);
      me = {...profile, uid:user.uid};
      renderAuth();
      start();
    });

    async function googleSignIn(){ const provider = new GoogleAuthProvider(); try{ await signInWithPopup(auth, provider);}catch(e){console.error(e);} }

    function renderAuth(){
      authArea.innerHTML = '';
      const av = create('div','avatar'); av.textContent = (me.displayName||'U')[0].toUpperCase();
      const name = create('div'); name.textContent = me.displayName || 'You';
      const wrap = create('div'); wrap.style.display='flex'; wrap.style.alignItems='center'; wrap.style.gap='8px';
      wrap.appendChild(av); wrap.appendChild(name);
      authArea.appendChild(wrap);
      const googleBtn = create('button'); googleBtn.textContent='Google Signin'; googleBtn.onclick=googleSignIn;
      const signOutBtn = create('button'); signOutBtn.textContent='Sign Out'; signOutBtn.onclick=()=>signOut(auth);
      authArea.appendChild(googleBtn); authArea.appendChild(signOutBtn);
    }

    function conversationId(a,b){ return [a,b].sort().join('_'); }

    // ---- Messaging: improved send/receive ----

    // Local optimistic pending map keyed by tempId to reconcile after server write
    const pendingMap = new Map();

    // Show messages array (serverDocs + pending local messages), sorted stable by timestamp + createdAt fallback
    function renderMessagesList(docs){
      // docs: array of message objects { id, data }
      // sort by timestamp (server) then localCreated (fallback)
      docs.sort((A,B)=>{
        const aTs = A.data.timestamp && A.data.timestamp.toMillis ? A.data.timestamp.toMillis() : (A.data._localCreated || 0);
        const bTs = B.data.timestamp && B.data.timestamp.toMillis ? B.data.timestamp.toMillis() : (B.data._localCreated || 0);
        if(aTs === bTs) return (A.id||'').localeCompare(B.id||'');
        return aTs - bTs;
      });

      messagesEl.innerHTML = '';
      docs.forEach(item=>{
        if(item.data.deleted) return;
        const m = item.data;
        const el = create('div','msg ' + (m.senderId === me.uid ? 'me' : 'other'));
        el.dataset.id = item.id;
        const text = escapeHtml(m.text || '');
        const tsText = m.timestamp && m.timestamp.toDate ? formatTimestamp(m.timestamp) : (m._localCreated ? formatTimestamp(new Date(m._localCreated)) + ' (sending...)' : '');
        el.innerHTML = `<div>${text}</div><div class="meta">${tsText}${m.senderId===me.uid ? ' · You' : ''}</div>`;
        // Allow deleting own messages when server id present
        if(m.senderId === me.uid && !item.id.startsWith('local_')){
          el.ondblclick = async ()=>{ if(confirm('Delete this message?')) await updateDoc(doc(db,'messages',item.id), { deleted:true }); };
        }
        messagesEl.appendChild(el);
      });
      // auto-scroll to bottom after rendering
      requestAnimationFrame(()=>{ messagesEl.scrollTop = messagesEl.scrollHeight; });
    }

    // Subscribe to conversation messages (only one subscription at a time)
    function subscribeToConversation(peerUid){
      if(messagesUnsub) messagesUnsub(); messagesUnsub = null;
      const convo = conversationId(me.uid, peerUid);
      const q = query(collection(db,'messages'), where('conversationId','==',convo), orderBy('timestamp','asc'));
      // We use onSnapshot to get server-synced messages; if timestamp isn't set yet (pending writes), Firestore returns them locally but timestamp is null; handle that in render.
      messagesUnsub = onSnapshot(q, snap=>{
        const docs = [];
        snap.forEach(docSnap=>{
          docs.push({ id: docSnap.id, data: docSnap.data() });
        });
        // merge with pending local messages for this conversation
        const pendingForConvo = Array.from(pendingMap.values()).filter(p=>p.conversationId === convo);
        pendingForConvo.forEach(p=>{
          // give pending docs a stable local id prefix so they sort predictably
          docs.push({ id: 'local_'+p.tempId, data: p });
        });
        renderMessagesList(docs);
      }, err=>{
        console.error('messages onSnapshot error', err);
      });
    }

    // Send message with optimistic UI and reliable write
    async function sendMessage(){
      const text = textInput.value.trim();
      if(!text) return;
      if(!activePeer){ alert('Select recipient'); return; }
      // Ensure conversation allowed (for your app rules you can change this)
      // Create local pending object
      const convo = conversationId(me.uid, activePeer.uid);
      const tempId = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
      const localCreated = Date.now();
      const pending = {
        tempId,
        conversationId: convo,
        senderId: me.uid,
        receiverId: activePeer.uid,
        text,
        deleted: false,
        _localCreated: localCreated
      };
      // show immediately
      pendingMap.set(tempId, pending);
      // re-render messages by forcing a local update (subscribe should already merge pending)
      // If no subscription yet, create one
      if(!messagesUnsub) subscribeToConversation(activePeer.uid);
      // Add to Firestore
      try{
        const docRef = await addDoc(collection(db,'messages'), {
          conversationId: convo,
          senderId: me.uid,
          receiverId: activePeer.uid,
          text,
          timestamp: nowTs(),
          deleted: false
        });
        // On successful write, remove pending entry that matches text + localCreated
        pendingMap.forEach((p, k)=>{
          if(p.tempId === tempId) pendingMap.delete(k);
        });
        // After server write, snapshot listener will include the new server doc
      } catch(e){
        console.error('Send failed', e);
        // leave pending with an error flag so user can retry
        const p = pendingMap.get(tempId); if(p) p._failed = true;
        alert('Message failed to send. Check connection and try again.');
      } finally {
        textInput.value = '';
      }
    }

    // Message list helpers
    function formatTimestamp(ts){
      if(!ts) return '';
      const d = ts.toDate ? ts.toDate() : new Date(ts);
      return d.toLocaleString([], {hour:'2-digit',minute:'2-digit',month:'short',day:'numeric'});
    }
    function escapeHtml(s){ return (s+'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]); }

    // ---- Chats list rendering (shows last message) ----
    function renderChatsList(){
      chatsList.innerHTML = '';
      // For demo: show users we follow (followsCache), otherwise show all cached users
      const uids = followsCache.size ? Array.from(followsCache) : Object.keys(usersCache).filter(id=>id!==me.uid);
      if(uids.length === 0){ chatsList.innerHTML = '<div class="small">No chats yet</div>'; return; }
      uids.forEach(uid=>{
        const u = usersCache[uid]; if(!u) return;
        const row = create('div','user-row');
        const av = create('div','avatar'); av.textContent = (u.displayName||'U')[0].toUpperCase();
        const body = create('div'); body.style.flex='1';
        const name = create('div'); name.style.fontWeight='700'; name.textContent = u.displayName || 'User';
        const meta = create('div'); meta.className='small'; meta.textContent = 'Loading last message...';
        body.appendChild(name); body.appendChild(meta);
        row.appendChild(av); row.appendChild(body);
        row.onclick = ()=>openChatWith(u);
        chatsList.appendChild(row);

        // Query last message for preview (order desc + limit 1)
        const convo = conversationId(me.uid, uid);
        const q = query(collection(db,'messages'), where('conversationId','==',convo), orderBy('timestamp','desc'), limit(1));
        onSnapshot(q, snap=>{
          if(snap.empty){ meta.textContent = u.bio || ''; return; }
          const m = snap.docs[0].data();
          const preview = (m.senderId === me.uid ? 'You: ' : '') + (m.text || '');
          meta.textContent = preview + ' · ' + (m.timestamp ? timeAgo(m.timestamp) : 'now');
        });
      });
    }

    function timeAgo(ts){
      if(!ts) return '';
      const d = ts.toDate ? ts.toDate() : new Date(ts);
      const s = Math.floor((Date.now() - d.getTime())/1000);
      if(s < 60) return `${s}s`; if(s < 3600) return `${Math.floor(s/60)}m`; if(s < 86400) return `${Math.floor(s/3600)}h`; return `${Math.floor(s/86400)}d`;
    }

    // ---- Open chat and subscribe ----
    function openChatWith(u){
      activePeer = u;
      chatEmpty.style.display='none';
      chatWrap.classList.remove('hidden');
      chatName.textContent = u.displayName || 'User';
      chatBio.textContent = u.bio || '';
      chatAvatar.textContent = (u.displayName||'U')[0].toUpperCase();
      // subscribe to messages for this convo
      subscribeToConversation(u.uid);
    }

    // ---- Start app after auth ----
    async function start(){
      // load some users (simple demo: subscribe to users collection)
      const q = collection(db,'users');
      onSnapshot(q, snap=>{
        snap.forEach(s=>{ const u = s.data(); usersCache[u.uid]=u; });
        // don't include self in caches when rendering lists
        delete usersCache[me.uid];
        renderChatsList();
      });
      // load follows for me
      const fq = query(collection(db,'follows'), where('followerId','==',me.uid));
      onSnapshot(fq, snap=>{
        followsCache.clear(); snap.forEach(s=>followsCache.add(s.data().followingId));
        renderChatsList();
      });

      // wire UI
      sendBtn.onclick = sendMessage;
      textInput.addEventListener('keydown', e=>{ if(e.key==='Enter') sendMessage(); });
    }

    // Helper to get doc ref for update
    import { doc as docRef } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-firestore.js";
    // minimal polyfill: use docRef above where needed (updateDoc uses docRef)

    // small utility to updateDoc (already imported above)
    // Note: updateDoc and doc were imported at top; if needed use updateDoc(doc(db,'messages',id), {...})

    // Safety: disable UI until authenticated
    chatWrap.classList.add('hidden');
    chatsList.innerHTML = '<div class="small">Waiting for auth...</div>';
  </script>
</body>
</html>
